

#ifndef _FSTORE_H_
#define _FSTORE_H_

#include <linux/types.h>

#define FSTORE_API_SUCCESS 0
#define FSTORE_API_FAILURE -1

/*
This API provides a feature store that tries to decouple reporting data from using it, in the kernel.
The idea is, any point in the kernel can report data, for example, every time a block_io is started,
we report the timestamp. Then, anyone wanting to build features from such data (a "combiner"), can
subscribe to multiple such reporting streams, and build features from the streams.

All functions return 0/-1 for success/failure, real return values are given through parameters.
*/

typedef void* map_ptr_t;
typedef u64 key_type_t;
typedef u64 val_type_t;
typedef void (*combiner_fn_t)(val_type_t*, void*);
typedef int combiner_id_t;

/*
This is a control plane operation for anyone wanting to report data, anywhere in the kernel. Reported data is stored using a key-value map.
id is a UUID for this reporting location, and key_id is a UUID for the key type.
Sometimes for efficiency, instead of maintaining many maps, we can store fields on the key struct itself. If this is the case,
the user can supply the offset on the key struct where there is scratch space, and how much there is (scratch_offs and scratch_sz).
If that is not possible, they can supply scratch_offs = -1.
Finally, they pass n_past_track to determine the size of the map (since we cannot store unbounded streams of data).
The function returns an opaque handle map_ptr_t to the created map, via the parameter map. 
*/
int fstore_register_map(const char* id, const char* key_id, int scratch_offs, unsigned scratch_sz, map_ptr_t* map, int n_past_track);

/*
This is a control plane operation for anyone wanting to consume reported data and build features from it, anywhere in the kernel. 
The core idea is, the consumer provides us a function that takes the reported values they are interested in, and produce a feature.
First, they provide the UUID's of the maps they are interested in, where n_maps is number of maps, and ids is the array of size n_maps
giving the UUID's.
Then, they provide fn, the aforementioned function, which takes a list of values (all u64's). The function generates a feature of
size n_bytes_ret.
The idea is, in the data plane function (fstore_combine), we will look up the relevant maps to get the values, and call the user's
function to build their feature. Then, we want to store it in a circular buffer of size n_past (so that they can look it up later).
This function returns an id (last param), identifying the registered combiner.
*/
int fstore_register_combiner_fn(int n_maps, int n_past, const char** ids, combiner_fn_t fn, int n_bytes_ret, combiner_id_t* id);

/*
This is the data plane operation for reporting data. It takes the map handle obtained from the register_map function, and inserts
(k,v) pair into that map.
*/
int fstore_insert(map_ptr_t p, key_type_t k, val_type_t v);

/*
This is the data plane operation for consuming data - i.e. combining reported data from several data streams, and creating a single
feature. This function takes the combiner_id created by the consumer in the register_combiner_fn function, and then supplies the
keys to use, to get values to feed the combiner function with. The params work as follows, to provide several options:
1) keys != null: keys is expected to have length n_maps as passed to the register_combiner_fn, and we look up in the maps based on these keys.
2) keys == null && lookup_dim != -1: find the most recently added key in map index lookup_dim, and use it to index all the maps. This is
only valid if all the maps we are interested in use the same key.
3) keys == null && lookup_dim == -1: find the most recently added key in each map, and use the respective key to index the map.
This function produces a feature by running the combiner function, and stores it in a circular buffer. It does not return the feature, that
is done by query_past function.
*/
int fstore_combine(combiner_id_t id, key_type_t* keys, int lookup_dim);

/*
This function allows querying the past n_past features generated by the combiner function given in id. Note n_past cannot be greater than
the n_past given to register_combiner_fn function. The function will fill the features in the val array, which has length n_past.
*/
int fstore_query_past(combiner_id_t id, int n_past, void** val);

#endif
